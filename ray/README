Names: Jeffery Wu, Allen Zheng

Known Issues: 
    - From Milestone 1, we didn't implement our anti-aliasing in aaImage(), but rather directly in trace()
    of RayTracer.cpp. This works, but we apologize for not clarifying that if we needed to. 
    - (EC) Torus object not traced on the GUI

Milestone 2 Requirements:
-----------------------------
TexMap/CubeMap: standard implementations as discussed in class, see material.cpp, CubeMap.cpp

Acceleration Structure: BVH w/ top down insertion.


Extra Credit: 
----------------------------
(Anti-aliasing code still in trace() function of RayTracer.cpp)

Stochastic Supersampling: Uses a DRV with Poisson Distribution to determine a threshold for whether or not supersampling should occur. The threshold is also dynamic on the scale of super-sample. Improves performance depending on the value of this threshold; of course the choice cannot be too aggressive or no anti-aliasing will occur. With just this consideration alone, on cone.ray, performance improves by approximately 55% for default settings.

Adaptive Supersampling: Considers within a super-sample whether the past few traces have been the same (which indicates no aliasing). If so, the super-sampling logic will "adapt" to skip tracing unneeded rays. Does not improve performance as much as our Stochastic consideration but still by around 10-20%. An improved policy (that has a better definition on where "jaggies" occur) could probably do better.


Extra Geometry: Torus (SceneObjects/Torus.cpp)
IMPORTANT: FOR THE NEXT EC, BORROWED QUARTIC SOLVER CODE FROM https://github.com/sasamil/Quartic.git (Sasa Milenkovic) LICENSE indicates fair use given its inclusion.
    - Reasoning: We originally tried to reason this (solving quartic) ourselves, but further down the line, we felt that deriving it was not a top concern considering the time commitment it was causing.

https://www.cl.cam.ac.uk/teaching/1999/AGraphHCI/SMAG/node2.html
The above link was our source for some of the Torus equations in the code. We reason that these equations and our subsequent derivations are correct; conceptually there are six possible ways to intersect the Torus from a maximum of four points (real roots of the above solved quartic). We updated the parser and build to recognize the Torus object. However, admittedly torus.ray does not trace anything, and we suspect it may be due to incorrect logic in normalization. We concede that we were unable to fix this before turning it in.

Extra Scene: torus.ray
This scene is meant to depict our new object, but does not trace due to above concerns. With a properly working torus code, it should depict a delectable donut, perhaps of the maple-glazed flavor.


